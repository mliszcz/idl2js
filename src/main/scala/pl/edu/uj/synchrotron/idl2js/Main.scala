package pl.edu.uj.synchrotron.idl2js

import scala.collection.JavaConversions._
import org.apache.axis2.corba.idl.parser._
import org.apache.axis2.corba.idl.types.IDL
import java.nio.file.{Paths, Files}
import java.nio.charset.StandardCharsets
import scala.util.control.Exception._
import java.io.{InputStream, ByteArrayInputStream}
import idl.DataTypeWithDependencyCheck._
import java.time.LocalDateTime
import org.apache.axis2.corba.idl.types.CompositeDataType
import java.nio.file.Path
import java.security.MessageDigest

object Main {

    def main(args: Array[String]) =
        allCatch.either { args.head }
        .right.flatMap { filename =>
            val filepath = Paths.get(filename)
            loadIDL(filepath)
                .right.flatMap(parseIDL)
                .right.map(sortTypes)
                .right.map(generateECMAScript)
                .right.map(attachHeaders(_,
                                         filepath.getFileName.toString,
                                         calculateSha1(filepath)))
        }
        .fold(println, println)

    def calculateSha1(filepath: Path) = {
        val bytes = Files.readAllBytes(filepath)
        val md = MessageDigest.getInstance("SHA1")
        md.update(bytes, 0, bytes.length)
        md.digest.map("%02X" format _).mkString
    }

    def loadIDL(filepath: Path) = allCatch.either {

        val bytes = Files.readAllBytes(filepath)

        val sanitized = new String(bytes)
            .replaceAll("\\*\\*/\n", "*/\n")
            .replaceAll("readonly ", "")
            .getBytes(StandardCharsets.UTF_8)

        new ByteArrayInputStream(sanitized)
    }

    def parseIDL(is: InputStream) = allCatch.either {

        val parser = new IDLParser(new IDLLexer(is))
        parser.specification

        val visitor = new IDLVisitor
        visitor.visit(parser.getAST)

        visitor.getIDL
    }

    def sortTypes(idl: IDL) = {

        import org.apache.axis2.corba.idl.types._

        idl.getCompositeDataTypes.toSeq.sortWith {
            case ( (_, t1: DataType), (_, t2: DataType) ) =>
                if (t1.getClass equals t2.getClass) (t1, t2) match {
                    case (t1: PrimitiveDataType, t2: PrimitiveDataType) =>
                        t1.getTypeName < t2.getTypeName
                    case (t1: CompositeDataType, t2: CompositeDataType) =>
                        t1.getName < t2.getName
                }
                else if (t1 dependsOn t2) true
                else t1.getPriority < t2.getPriority
        }.asInstanceOf[Seq[(String, CompositeDataType)]]
    }

    def generateECMAScript(types: Seq[(String, CompositeDataType)]) = {

        import org.apache.axis2.corba.idl.types._

        import EsType._

        val jsTypes = types.map {
            case (_, v: Typedef) => v.toJs
            case (_, v: EnumType) => v.toJs
            case (_, v: Struct) => v.toJs
            case (_, v: UnionType) => v.toJs
            case (_, v: Interface) => v.toJs
            case (_, v) => s"""// UNKNOWN TYPE: ${v.getName}"""
        }

        jsTypes.mkString("\n\n")
    }

    def attachHeaders(esCode: String,
                      sourceFile: String,
                      sourceSha1: String) = {

        val separator = "-" * 76

        val header = s"""
                    |// $separator
                    |// GENERATED BY ${BuildInfo.name} v${BuildInfo.version}
                    |// source: $sourceFile
                    |// sha1: $sourceSha1
                    |// date: ${LocalDateTime.now}
                    |// $separator"""
                    .stripMargin

        val enum = Option(getClass getResourceAsStream "/Enum.js")
                    .map { io.Source.fromInputStream }
                    .map { _.mkString }
                    .getOrElse("")

        s"""$header
           |
           |$enum
           |// $separator
           |
           |$esCode
           |"""
           .stripMargin
    }
}
